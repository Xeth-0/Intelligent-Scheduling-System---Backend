generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // or "mysql", "sqlite", etc.
  url      = env("DATABASE_URL")
}

// ================== Enums ==================
enum Role {
  ADMIN
  TEACHER
  STUDENT
}

enum ClassroomType {
  LECTURE
  LAB
  SEMINAR
}

// ================== Campus ==================
model Campus {
  campusId         String       @id @default(uuid())
  name             String
  location         String?
  schedulingPolicy String?
  departments      Department[]
  classrooms       Classroom[]
}

// ================== User ==================
model User {
  userId       String       @id @default(uuid())
  firstName    String
  lastName     String
  email        String       @unique
  passwordHash String
  role         Role
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  teacher      Teacher?
  admin        Admin?
  student      Student?
  Schedule     Schedule[]
  Preference   Preference[]
}

// ================== Teacher ==================
model Teacher {
  teacherId    String       @id @default(uuid())
  user         User         @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userId       String       @unique
  departmentId String?
  preferences  Preference[]
  subjects     Course[]
}

// ================== Student ==================
model Student {
  studentId      String       @id @default(uuid())
  user           User         @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userId         String       @unique
  studentGroup   StudentGroup @relation(fields: [studentGroupId], references: [studentGroupId], onDelete: Cascade)
  studentGroupId String
}

// ================== Admin ==================
model Admin {
  adminId String @id @default(uuid())
  user    User   @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userId  String @unique
}

// ================== Department ==================
model Department {
  departmentId String         @id @default(uuid())
  name         String
  campus       Campus         @relation(fields: [campusId], references: [campusId], onDelete: Cascade)
  campusId     String
  subjects     Course[]
  StudentGroup StudentGroup[]
}

// ================== Subject ==================
model Course {
  subjectId       String         @id @default(uuid())
  name            String
  description     String?
  code            String
  sessionTypes    String[]
  sessionsPerWeek Int[]
  studentGroupIds StudentGroup[] // ! Should be a list, of a list of student groups
  department      Department?    @relation(fields: [departmentId], references: [departmentId], onDelete: SetNull)
  departmentId    String?
  teacher         Teacher?       @relation(fields: [teacherId], references: [teacherId], onDelete: SetNull) // ! Should be a list of teachers
  teacherId       String?
  Schedule        Schedule[]
	@@map("Subject")
}

// ================== StudentGroup ==================
model StudentGroup {
  studentGroupId            String     @id @default(uuid())
  name                      String
  size                      Int
  accessibilityRequirements Boolean
  department                Department @relation(fields: [departmentId], references: [departmentId], onDelete: Cascade)
  departmentId              String
  students                  Student[]
  Schedule                  Schedule[]
  subjects                  Course[]
}

// ================== Classroom ==================
model Classroom {
  classroomId String        @id @default(uuid())
  name        String
  capacity    Int
  type        ClassroomType
  campus      Campus        @relation(fields: [campusId], references: [campusId], onDelete: Cascade)
  campusId    String
  openingTime String?
  closingTime String?
  Schedule    Schedule[]
}

// ================== Schedule ==================
model Schedule {
  scheduleId     String        @id @default(uuid())
  subject        Course       @relation(fields: [subjectId], references: [subjectId], onDelete: Cascade)
  subjectId      String
  teacher        User          @relation(fields: [teacherId], references: [userId], onDelete: Cascade)
  teacherId      String
  classroom      Classroom?    @relation(fields: [classroomId], references: [classroomId], onDelete: SetNull)
  classroomId    String?
  startTime      DateTime
  endTime        DateTime
  isFinalized    Boolean       @default(false)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  studentGroup   StudentGroup? @relation(fields: [studentGroupId], references: [studentGroupId], onDelete: SetNull)
  studentGroupId String?
}

// ================== PreferenceType ==================
model PreferenceType {
  preferenceTypeId String          @id @default(uuid())
  key              String          @unique
  description      String?
  possibleValues   PossibleValue[]
  Preference       Preference[]
}

// ================== PossibleValue ==================
model PossibleValue {
  possibleValueId  String         @id @default(uuid())
  value            String
  preferenceType   PreferenceType @relation(fields: [preferenceTypeId], references: [preferenceTypeId], onDelete: Cascade)
  preferenceTypeId String
  Preference       Preference[]
}

// ================== Preference ==================
model Preference {
  preferenceId     String         @id @default(uuid())
  user             User           @relation(fields: [userId], references: [userId], onDelete: Cascade)
  userId           String
  preferenceType   PreferenceType @relation(fields: [preferenceTypeId], references: [preferenceTypeId], onDelete: Cascade)
  preferenceTypeId String
  value            PossibleValue  @relation(fields: [possibleValueId], references: [possibleValueId], onDelete: Cascade)
  possibleValueId  String
  teacher          Teacher?       @relation(fields: [teacherId], references: [teacherId], onDelete: SetNull)
  teacherId        String?
}

// ================== RefreshToken ==================
model RefreshToken {
  refreshTokenId String   @id @default(uuid())
  userId         String
  token          String
  expiresAt      DateTime
  createdAt      DateTime @default(now())
}
